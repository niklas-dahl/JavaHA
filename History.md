#History (zurück zur [Haupt-Readme](../../)?)
Die History wurde etwas zu lang, deshalb hab ich sie in eine eigene Datei verschoben...

__Derzeitiger Gesamtstatus:__ ...frag nicht :(

Gesamtpunkte (/7) = Funktionalität (/5) + Wartbarkeit (/2).

| Nr. | Punkte (/7) | Kommentar
|----:|:-----------:|---
| 10  | 3+2=5 :hankey: | Methoden, die ihr abtract macht und überschreiben wollt, müssen die selbe Signatur besitzen. Heißt ihr hättet refreshMoves in der Chessman-Klasse ebenfalls protected machen müssen, zumal es sonst nicht kompiliert (-1 func). Sooo. Vom Prinzip her solltet ihr euch an die vorgegebenen Methoden und Signaturen halten. Ich halte es auch nicht für sinnvoll, die MoveList zwischen zu speichern, da sie sich "im realen Leben" nach jedem Zug ändert. Bezüglich Laufzeit ist es natürlich gut, dass ihr euch Gedanken gemacht habt, aber das ist in diesem Beispiel (und eben auch im echten Schach, wo euch das Zwischenspeichern nullkommagarnichts bringt) zu vernachlässigen (-1 func auf Grund der Signatur).
| 9   | 3+2=5 :sob::sob:| Das Lösen / Mischen mittels Exception-Handling funktioniert zwar, ist aber kein schöner Stil. Dann lieber eine zusätzliche "pruefe(x,y)"-Funktion einbauen und entsprechend aufrufen (kein Punktabzug). In mische() verlasst ihr euch darauf, dass die 0 immer unten rechts steht. Sollte das nicht so sein, wird u.U. eine "WrongMoveException" geworfen (-1 func). Entsprechende Funktionalität habt ihr für das Lösen eingebaut, warum nicht auch beim mischen? Der Getter tuts nicht. Dadurch kann das Feld von außen verändert werden (Stichwort "tiefe Kopie", -1 func).
| 8   | 5+2=7       | Im Konstruktor hättet ihr - theoretisch - jede Karte einzeln kopieren müssen, anstatt das ganze Array zu übernehmen (Stichwort "tiefe Kopie"). Das ist in dieser Aufgabe nicht schlimm, spätestens wenn ihr im vierten Semester Rechnernetze habt und ein Spiel wie Labyrinth oder so programmieren müsst, ist sowas extrem ärgerlich, da es nicht direkt auffällt. Ansonsten ist eure Lösung schön und kompakt.
| 7   | 5+2=7       | Funktioniert alles.
| 6   | 4+2=6 :sob: | Läuft alles fehlerfrei. Alternativ zu "Math.pow(2, x)" könnt ihr auch "1 << x", den (Bit)Shift-Operator verwenden. Der schiebt alle Bits der angegebenen Zahl (hier 1) um x Bitstellen nach links (was im Endeffekt analog zu 1*(2^x) ist). Habe ich damals selber nicht gemacht, sieht aber cooler aus und dürfte schneller sein ;) Für BigInteger.intValue() muss ich euch aber einen Punkt abziehen, da ihr den String selbstständig in einen Integer umwandeln solltet.
| 5   | 5+2=7       | Euer eigene Adressdatei hättet ihr mir ruhig dazulegen können. Hashmap toString() würde ich nicht verwenden, da die ganzen Adressen dann nebeneinander stehen, was unübersichtlich ist (da es so auch in der Beispielausgabe der Aufgabenstellung steht, kein Punktabzug). Nehmt die Kommentierung wieder ein bisschen ernster, sollten die Korrekteure wechseln, würde es mich nicht wundern, wenn man euch dafür Punkte abzieht.
| 4   | 5+2=7       | Schöne Lösung.
| 3   | 5+2=7       | Die Funktionen getMax() und getMaxIndex() machen praktisch das Gleiche, also hättet ihr zur Berechnung der größten Zahl auch einfach values[getMaxIndex()] nehmen können. Parser-Funktionen bei Benutzereingaben würde ich normalerweise immer in einem try-catch machen, auch wenn das in diesem Fall nicht gefordert.
| 2   | 5+2=7       | Die uns gegebene Musterlösung arbeitet mit einem int-Array (-1 für nicht vorhanden, 0 für verfügbar und 1 für belegt), die meisten anderen Gruppen haben ein char-Array verwendet, daher wurde da der Konstruktor benötigt, um die Arrays zu initialisieren. Das spart ihr euch natürlich mit einem boolean-Array und der entsprechenden Hilfsmethode "platzGueltig". Gefällt mir persönlich auch besser.
| 1   | 5+2=7       | Streng genommen solltet ihr gucken, was die "Stoppwatch" so tut, nicht die "Stoppuhr" ;) (kein Punktabzug).
